PRD: AI-Powered Personalized Recommendations for Goodreads
1. Overview

We are extending Goodreads with a new feature that provides AI-powered book recommendations. The goal is to make book discovery feel more personalized and transparent, while keeping the overall experience lightweight and not overwhelming the existing Goodreads interface.

This feature will be built as a Next.js web application with a MongoDB backend. The application assumes a single-user mode — no authentication or multi-user support is required. Core Goodreads-like features (main feed, profile, bookshelves) will be scaffolded, with the new AI recommendation feature layered on top.

2. Goals

Provide personalized, explainable book recommendations.

Enable users to interact with AI for conversational recommendations or view pre-generated suggestions.

Allow users to seamlessly add discovered books to their To Read shelf.

Maintain simplicity: one user only, minimal clutter, no login or social features.

3. Non-Goals

No multi-user support or authentication.

No book progress tracking, likes, or commenting.

No recommendation algorithm complexity beyond embeddings + lightweight similarity scoring.

No need to replicate full Goodreads UI fidelity.

4. Core Features
A. Goodreads Basics (Scaffold)

Homepage / Feed: displays a default feed of bookshelves and recent books.

Bookshelves: three shelves — Read, To Read, Reading.

Profile: shows counts of books on each shelf.

Book Management: user can add a book to one of the shelves.

B. AI Recommendation Entry Point

On the homepage, a Recommendation Box appears.

Prompts: “Want a personalized recommendation?”

Options:

Text Input: user can describe what they’re looking for (e.g., “I want something like The Martian but funnier”).

Pre-Generated Suggestions: a few clickable “recommendation seeds” (e.g., “Cozy fantasy,” “Page-turning thrillers”).

Clicking either option navigates to a dedicated Recommendations Page.

C. Recommendations Page

Displays a list of recommended books.

Each recommendation includes:

Book cover, title, author, short description.

“Why this book” explanation (generated by AI).

Action button: “Add to To Read.”

User can give feedback:

“Like these” → load new recommendations in same vein.

“Not for me” → refine and re-run recommendation logic.

D. Iteration Loop

After feedback, new recommendations appear.

Loop continues until user is satisfied or navigates away.

5. Data Model

MongoDB collections:

Book

id (string)

title (string)

author (string)

genres (array)

description (string)

coverUrl (string)

embedding (array of floats, from OpenAI API)

UserState (singleton)

favoriteIds (array of Book IDs)

readIds (array of Book IDs)

toReadIds (array of Book IDs)

readingIds (array of Book IDs)

feedbackHistory (array of feedback events)

Feedback

bookId (string)

action (enum: like | dislike)

timestamp

6. AI Recommendation Feature
A. Retrieval

Book metadata (title, author, subjects, description) is fetched from Open Library API.

Descriptions are embedded using OpenAI’s text-embedding-3-small model.

User queries are embedded with the same model.

System computes cosine similarity between query embedding and stored book embeddings.

Returns top-N recommendations.

B. Explanation

For each recommendation, the system calls OpenAI’s gpt-4o-mini model with:

User’s query

Candidate book’s metadata (title, author, description)

Model generates a short explanation:
“We recommended this because it shares cozy fantasy themes and emphasizes friendship, similar to your query.”

C. Feedback Loop

User clicks Like or Not for me.

Feedback is stored in Feedback collection.

On next run, disliked books are filtered out; liked books can increase weight for similar genres/authors.

7. Data Source: Open Library

Search API: https://openlibrary.org/search.json?q=QUERY&limit=30

Work details: https://openlibrary.org/works/OLxxxxW.json

Covers: https://covers.openlibrary.org/b/id/{coverId}-L.jpg

Mapping:

title → title

author_name[0] → author

subject → genres

description → description (may be sparse; fallback to short summary if missing)

cover_i → coverUrl

8. User Flows
Flow 1: Add Book to Shelf

User browses a book.

Clicks Add to Shelf → selects Read / To Read / Reading.

MongoDB updates the UserState document.

Flow 2: Get Recommendations

User sees Recommendation Box on homepage.

Inputs text query or clicks pre-generated seed.

Redirects to Recommendations Page.

Backend fetches candidate books from MongoDB (seeded from Open Library).

Embedding similarity → top matches returned.

AI generates explanations.

User views results, optionally adds a book to To Read.

Flow 3: Feedback Loop

User clicks “Like” or “Not for me.”

Feedback stored in MongoDB.

Recommendation engine re-scores books and returns new set.

9. Technical Requirements

Frontend: Next.js (App Router), Tailwind CSS, shadcn/ui for components.

Backend: Next.js API routes + Mongoose ORM.

Database: MongoDB Atlas.

Deployment: Vercel for hosting.

Data Source: Open Library API (search + works + covers).

AI Integration:

Embeddings: OpenAI text-embedding-3-small for semantic search.

Chat: OpenAI gpt-4o-mini for generating explanations.

Cost:

Embedding 200 books ≈ $0.02 (one-time).

Generating explanations for 5–10 recs ≈ $0.01 per run.

Well within free credits ($5) or a few cents total.

10. Success Criteria

User can add books to shelves (Read, To Read, Reading).

Homepage shows Recommendation Box with both input and pre-generated options.

Recommendations Page loads at least 5 AI-powered suggestions with “Why this book” reasons.

User can add a recommended book to their To Read shelf.

Feedback buttons re-run recommendations and update results.

All book data sourced from Open Library.

Total AI costs remain under $1 for demo scale.